<!DOCTYPE html>

<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width;initial-scale=1.0">
	<title>3W атаки</title>
	<link href="default.css" rel="stylesheet" />
</head>
<body>

	<h1>Навигатор по этапам</h1>
	<p>На данной странице вы можете пройтись по этапам.</p>
	<p>Информация, полученная при выполнении 
	   данных этапов будет помогать вам понимать возможные уязвимости и не совершать ошибки.
	   Наверное.</p>
	<p style="color:#c00">
		Делая всё то же самое во благо своего кармана или
		во вред кому-то можно <strong>пойти по другим этапам</strong>! 
		Допустимо применение только при законном тестировании сайтов 
		на уязвимости (своих или работодателя/нанимателя). Для этого
		уже должна быть договорённость о подобных действиях, что вам
		их разрешают выполнять.</p>
	<p>Выполните задания/действия, ответьте на вопросы и напишите отчёт о том, как вы это делали.
	   Отчёт с картинками! В отчёте главное - это красивые картинки,
       которые будут у всех различаться. <strong>У задания главное - чтобы у вас в голове
       что-нибудь осталось</strong>.</p>
       
    <div>
		<h2>Немного о HTTP</h2>
		<p>HTTP - это протокол передачи гипертекста (текст с разметками), который сейчас
		   передаёт много всего другого, которое не всегда гипер, и не всегда текст.</p>
		<p>Протокол основывался на парадигме 1 запрос - 1 ответ. Раньше был 1 запрос в рамках одного
		   соединения, начиная с версии протокола HTTP/2.0 - много запросов в рамках соединения, 
		   но все они выполняются по одним и тем же правилам: запрос-ответ.</p>
		<p>Как выглядит запрос HTTP? Примерно так:</p>
		<pre>
GET /some-location HTTP/1.1
Host: graphworld.ru
Header1: Some header 1 value
Header2: Some header 2 value

Это тело запроса, его может не быть</pre>
		
		<p>А ответ может выглядеть так:</p>
		<pre>HTTP/1.1 200 OK
Header1: Some header 1 value
Header2: Some header 2 value

Это тело ответа, оно как правило есть, но может и отсутствовать, 
если в заголовках достаточно информации</pre>

		<p>Обо всём этом можно узнать поподробнее открыв инспектор через F12 в браузере и 
		   посмотреть на вкладке Сеть заголовки запросов и ответов, их тело и прочее, а также
		   почитать немного информации об этом</p>

		<p>Формат запроса такой:
			<ul>
				<li>В первой строке указывается метод, ресурс и протокол, например <strong>POST /hello HTTP/1.1</strong></li>
				<li>Далее каждая непустая строка содержит запись в виде <strong>Заголовок: Значение</strong>,
				    которые позволяют уточнить запрос.</li>
				<li>После первой пустой строки идёт тело запроса</li>
				<li>Перенос строки специфичный и выглядит как: "\r\n" на языке C</li>
			</ul>
		</p>
		<p>Формат ответа такой:
			<ul>
				<li>В первой строке указывается протокол, код ответа, 
				    необязательное сообщение, например <strong>HTTP/1.1 200 OK</strong></li>
				<li>Далее каждая непустая строка содержит запись в виде <strong>Заголовок: Значение</strong>,
				    которые позволяют уточнить запрос.</li>
				<li>После первой пустой строки идёт тело запроса</li>
				<li>Перенос строки специфичный и выглядит как: "\r\n" на языке C</li>
			</ul>
		</p>
		<p>Чем-то они похожи, верно?</p>
		<p>В спецификации описано много методов, например 
		   <strong>GET, POST, PUT, DELETE, HEAD, OPTIONS, PATCH</strong>.</p>
		<p>Также описаны коды ответов. Они разбиваются на категории.
			<ul>
				<li>Коды <strong>1XX</strong> - смена протокола, например, на Websocket.</li>
				<li>Коды <strong>2XX</strong> - успешный ответ. 200 - OK, 201 - Created.</li>
				<li>Коды <strong>3XX</strong> - перенаправление. 302 - Found, 301 - Moved permanently.
				    Обычно используются с заголовком Location</li>
				<li>Коды <strong>4XX</strong> - ошибка пользователя. 
				    404 - Not found, 403 - Forbidden, 401 - Unathorized.</li>
				<li>Коды <strong>5XX</strong> - ошибка на стороне сервера. 500 - Internal Server Error</li>
			</ul>
		</p>
				   
		<p>Браузер - не единственная программа, которая может работать через HTTP.</p>
		<p>Парадигма REST - это обмен сообщениями через HTTP. Нет состояния у соединения,
		   вся необходимая информация передаётся вместе с запросом. У нас есть какие-то 
		   ресурсы, у них есть URL. И к ним применяем методы GET, PUT, POST, DELETE и прочие.</p>
		<p>Часто используется в микросервисах - маленьких серверных программах, выполняющих
		   какие-либо отдельные действия.</p>
		
		<p>Данный протокол один из столпов сети. Остальное можно 
		   почитать в соответствующих документах RFC или как-то по-другому
		   узнать самим.</p>
		
		<p>Теперь перейдём к заданиям</p>
    </div>
       
	<ul>
		<li>
			<h2>Атака SQL-Injection (Внедрение SQL кода)</h2>
			<p><a href="sql-injection">Авторизация и внедрение SQL (SQL Injection).</a></p>
			<p>Вам нужно войти за пользователя admin, но за него войти нельзя, так как пароль не задан.</p>
			<p>Не беда! Код сервера был написан из рук вон плохо (что хорошо).</p>
			<p>Используйте атаку SQL-инъекция из класса внедрения кода для того, чтобы это сделать.</p>
			<p>Подумайте, и напишите в отчёте, как от такой атаки защищаться. Ответьте на вопросы:</p>
			<ul>
			    <li>Поможет ли экранирование пришедших извне параметров, и что это вообще такое экранирование?</li>
			    <li>Помогут ли "вставки" параметров? То есть запросы вида: 
					<strong>SELECT * FROM table WHERE column1=? AND column2=?</strong>
					с последующей подстановкой значений в заранее заданные места с помощью специальной функции?</li>
			    <li>Помогут ли для этого специальные библиотеки ORM (Object-Relation Mapping) и прочие,
				    которые сами составляют запросы для получения и сохранения объектов из/в базу данных?</li>
			</ul>
		</li>
		<li>
			<h2>Атака XSS (Межсайтовый скриптинг)</h2>
			<p>
				<a href="/xss/comments/">Комментарии и Кража данных через межсайтовый скриптинг (XSS)</a>
				и 
				<a href="/xss/passwords/">просмотр украденных паролей</a>
			</p>
			<p>Кто сказал, что внедрять можно только SQL-код? То же самое можно сделать и 
			   через другие механизмы, где присутствует кодогенерация. Такие кусочки программы нужно защищать.</p>
			<p>HTML страницы допускают различные вставки. Если ввод не обрабатывается и после отправляется пользователю,
			   то можно получить очень нехорошие последствия, так как через JavaScript можно многое поменять.</p>
			<p>Вообще, не стоит доверять хранить логику в неподконтрольных местах, так как тем самым создаётся
			   потенциальная проблема</p>
			<p>Напишите комментарий такого содержания: 
			   <strong>&lt;script&gt; alert('Данный сайт подвержен XSS атаке'); &lt;/script&gt;</strong>.
			   Что-то случилось?</p>
			<p>Попробуйте написать написать нужный комментарий, который изменяет место, куда 
                           посылаются данные из формы входа со страницы с
			   <strong>/xss/comments</strong> на страницу <strong>/xss/passwords/</strong> (слеш на конце обязателен, так как
			   это особенность настройки сервера, иначе вам вернётся ответ с перенаправлением с /xss/passwords на /xss/passwords/). Для этого нужно 
			   в комментарий вставить JavaScript-код в <strong>&lt;script&gt; &lt;/script&gt;</strong>, где найти первую форму 
			   (тег form, можете использовать document.forms[0] в коде JavaScript) и заменить аттрибут 
			   action на <strong>/xss/passwords/</strong></p>
			<p>По адресу /xss/passwords/ расположен скрипт, который принимает POST запрос и записывает данные в базу в JSON формате.</p>
			<p>Таким образом, любой введённый логин и пароль отправляются злоумышленнику.</p>
			<p style="color:#a00">Это пример, а не руководство к действию! Цель задания понять, как это работает, почему это опасно и как с этим бороться!</p>
			<p>Собственно, в отчёте нужно написать, как можно с этим бороться. Например, как можно убрать весь JS код из строки. 
			   Можно ли это сделать экранированием? Ответ вас поразит.</p>
		</li>
		<li>
			<h2>Атака CSRF</h2>
			<p>
				<a href="csrf/bank">Банк</a> 
				и 
				<a href="csrf/fish">Отправка запроса от имени авторизованного 
									пользователя со стороннего сайта</a>
			</p>
			<p>Логин <strong>user</strong>, пароль <strong>password</strong></p>
			<p>Для авторизации на сайте часто используют Cookie. В них записывается какое-то
			   значение, которое будет храниться в браузере. Данной Cookie устанавливают флаг
			   HttpOnly чтобы нельзя было Cookie украсть. Не беда! Печеньки пересылаются каждый
			   раз, когда пользователь заходит на сайт автоматически. Если мы отправим форму
			   на данный сайт, то cookie будут отправлены вместе с запросом. Сайт же совпадает.</p>
			<p>Собственно, на этом и основана атака. Создаётся возможность с одного сайта отправить
			   запрос на другой сайт, который выполнит необходимые действия.</p>
			<p>В данном примере немногоуважаемый господин просит поставить лайк котику и поделиться 
			   попугаями со счёта в банке. Когда нажимаем на кнопку, происходит запрос на другую страницу.
			   Если вы там авторизованы, то попугаи переведутся</p>
			<p style="color:#f00">Попугаи* - это очень перспективная монета. Обеспечена не более, чем
			   доверием людей к ней, как криптовалюты и прочие деньги. Имеет право на существование.</p>
			<p>В данном задании мы "делимся" с другим пользователем попугаями.
			   Попугаи лишними никогда не бывает, поэтому их нужно вернуть.</p> 
			<p>Разберём ещё одну нехорошую ситуацию, когда
			   проверка параметров совершается только на клиенте. 
			   Клиент-серверные приложения имеют интерфейс взаимодействия, 
			   и клиент может быть заменён на другой, более сговорчивый.
			   <strong>Тогда сервер оказывается беззащитным перед теми данными, 
			   которые посылает его новый "партнёр"</strong>.</p>
			<p>На данном сервере по счастливой случайности такая фильтрация осуществляется только на клиенте.
			   Используя любой инструмент, отличный от браузера, пошлите запрос серверу. 
			   Можно использовать программу <strong>curl</strong>. 
			   Запрос <strong>POST</strong>, укажите отрицательный параметр <strong>ammount</strong>.
			   Не забудьте про ваши печеньки (cookies), их нужно указать в запросе в заголовке Set-Cookie.
			   Можно посмотреть в браузере. Для входа в инспектор используйте клавишу F12 
			   (или другую с менее стандартными браузерами, уточните сами).</p>
			<p>Что происходит?</p>
			<p>Как защититься от такой атаки? Подумайте или поищите что такое CSRF-токен.</p>
		</li>
		<li>
			<h2>Соревнование процессов и асинхронность</h2>
			<p>Идём <a href="race">сюда</a> и гоняем!</p>
			<p>Вы - пользователь <strong>Nagibator3000</strong> с очень тайным паролем - <strong>Nagibator3000</strong></p>
			<p><strong>В чём суть проблемы?</strong> Мы делаем несколько запросов подряд.
				В первом - проверка. Во втором - запрет на повторение действий. В третьем - изменение данных.</p>
			<p>Между проверкой и запретом существует временной интервал, когда проверка ещё будет проходить,
			   поэтому возможно начать несколько действий. Ну, и они могут даже выполниться.
			   Например, в данном задании вы можете много раз вернуть один предмет на странице игрового магазина.
			   В итоге мы получаем проблему чтения <strong>грязных</strong> данных.
			</p>
			<p>При нажатии на кнопку <strong>Вернуть</strong> происходит POST-запрос на сервер.
			   На сервере происходит проверка, вернули заказ или нет через SELECT - это запрос №1.
			   Далее происходит изменение данных и делается отметка, что заказ возвращён.
			   Для примера специально между данными действиями была добавлена задержка. 
			   <strong>В итоге вы можете много раз нажать на кнопку и запрос выполнится несколько раз.</strong>
			   То есть вы несколько раз вернёте средства за покупку... Непорядок? А то!</p> 
		</li>
	</ul>

</body>
</html>
